[{"content":"EF Core 데이터베이스와 객체 지향 언어 간에 호환되지 않는 데이터를 변환해 매핑해주는 기법을 객체 관계 매핑(ORM)이라고 합니다.\nEF Core 는 .Net 기반 개체를 이용하여 데이터베이스를 작업할 수 있도록 해줍니다.\n요구사항 .NET SDK : https://dotnet.microsoft.com/en-us/download Visual Studio : https://visualstudio.microsoft.com/ko/vs/ 설치 EntityFrameworkCore 패키지 설치\n검색을 통해 설치 도구 \u0026gt; NuGet 패키지 관리자 \u0026gt; NuGet 패키지 관리 패키지 검색: EntityFrameworkCore 명령을 실행해 설치 도구 \u0026gt; NuGet 패키지 관리자 \u0026gt; 패키지 관리자 콘솔 명령 실행: Install-Package Microsoft.EntityFrameworkCore Provider 패키지 설치\n아래의 패키지 중에서 사용하는 DB의 패키지를 설치하면 됩니다.\n자세한 내용은 이 링크를 확인해주세요. 데이터베이스 시스템 패키지 SQL Server 및 SQL Azure https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.SqlServer SQLite https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Sqlite Azure Cosmos DB https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.Cosmos PostgreSQL https://www.nuget.org/packages/Npgsql.EntityFrameworkCore.PostgreSQL/ MySQL https://www.nuget.org/packages/Pomelo.EntityFrameworkCore.MySql/ EF Core 메모리 내 데이터베이스** https://www.nuget.org/packages/Microsoft.EntityFrameworkCore.InMemory 패키지 관리자 콘솔 도구 설치\n설치: Install-Package Microsoft.EntityFrameworkCore.Tools EF Core 시작하기 Visual Studio 실행 후 새 프로젝트 만들기 C# 태그가 있는 콘솔 앱을 선택해 다음 클릭 이름(예, EFCoreTest)을 입력하고 만들기 클릭 위의 설치 방법을 참고해 원하는 방법으로 패키지 설치 DBContext 구성 데이터베이스와 연결하고 쿼리 및 저장하는 데 필수적인 요소 아래와 같이 DbContext 를 상속한 클래스 내부에 Entity 와 DB 연결 정보 등을 추가할 수 있습니다. public class TestDbContext : DbContext { } 여기서 사용한 방식은 디자인 타임 팩터리라는 인터페이스를 구성하여 DbContext를 만드는 방법을 도구에 알리는 방법입니다.\nDB와의 연결은 여러가지 방식을 사용할 수 있습니다. 자세한 사항은 맨 아래의 참고링크를 확인해주세요.\n디자인 타임 팩터리 방식은 이 링크를 확인하세요.\nDbContext 을 아래와 같이 구성합니다. public class TestDbContext : DbContext { public TestDbContext(DbContextOptions\u0026lt;TestDbContext\u0026gt; options) : base(options) { } } 아래과 같이 디자인 타임 팩터리에서 DbContext 를 만드는 방법을 구성합니다. public class TestContextFactory : IDesignTimeDbContextFactory\u0026lt;TestDbContext\u0026gt; { public TestDbContext CreateDbContext(string[] args) { var optionsBuilder = new DbContextOptionsBuilder\u0026lt;TestDbContext\u0026gt;(); optionsBuilder.UseNpgsql(\u0026#34;Server=server.maum.in; Port=25432; Database=plutslet0316; user id=plutslet0316; password=plutslet0316\u0026#34;); return new TestDbContext(optionsBuilder.Options); } } 모델 만들기 클래스 형태로 구성한 Entity 를 위에서 만든 DbContext 에 속성으로 정의하는 것만으로도 DB의 테이블과 연결시킬 수 있습니다. 다음과 같이 사용자 정보와 사용자의 좋아하는 것들이 담길 클래스 생성합니다. public class UserInfo { public int Id { get; set; } public string Name { get; set; } public ICollection\u0026lt;Favorite\u0026gt; Favorites { get; set; } = new List\u0026lt;Favorite\u0026gt;(); } public class Favorite { public int Id { get; set; } public string Value { get; set; } public int UserId { get; set; } // public UserInfo User { get; set; } } 구성한 DbContext 에 해당 클래스를 DBSet으로 정의합니다. public class TestDbContext : DbContext { public DbSet\u0026lt;UserInfo\u0026gt; UserInfos { get; set; } public DbSet\u0026lt;Favorite\u0026gt; Favorites { get; set; } ... } 데이터베이스 만들기 위에서 구성한 데이터베이스를 서버에서 만들기 위해서는 마이그레이션이라는 과정이 필요합니다. 패키지 관리자 콘솔에서 Add-Migration 고유값 실행 각각의 마이그레이션은 고유한 값이 필요합니다. 패키지 관리자 콘솔에서 Update-Database 실행 해당 명령어로 C#으로 작성한 데로 테이블을 만들거나 수정하는 등 데이터베이스에 업데이트합니다. 기본적인 사용 방법 데이터베이스 연결\n위에서 만든 DBContext 를 가져옵니다. using var dc = new TestContextFactory().CreateDbContext([]); 생성/수정\nvar favorites = new List\u0026lt;Favorite\u0026gt;(); favorites.Add(new Favorite { Value = \u0026#34;포도\u0026#34; }); favorites.Add(new Favorite { Value = \u0026#34;바나나\u0026#34; }); favorites.Add(new Favorite { Value = \u0026#34;망고\u0026#34; }); var info = new UserInfo { Name = \u0026#34;User 1\u0026#34;, Favorites = favorites }; // 해당 메서드를 이용해 모든 변경사항을 DB에 저장할 수 있다. dc.SaveChanges(); 읽기\nvar result = await dc.UserInfos .Include(x =\u0026gt; x.Favorites) // 목록 불러오기 .ToListAsync(); foreach (var info in result) { var favoriteText = \u0026#34;\u0026#34;; var favorites = info.Favorites.ToList(); var count = favorites.Count(); for (var i = 0; i \u0026lt; count; i++) { favoriteText += favorites[i].Value; if (i \u0026lt; count - 1) favoriteText += \u0026#34;, \u0026#34;; } Console.WriteLine($\u0026#34;{info.Id}: {info.Name}\u0026#34;); Console.WriteLine($\u0026#34;{favoriteText}\u0026#34;); } 삭제\ndc.UserInfos.RemoveRange(dc.UserInfos); dc.SaveChanges(); 이번엔 설치와 간단한 사용법까지 알아봤습니다.\n다음에 기회가 되면 더 많은 내용을 다뤄보겠습니다.\n참고링크 공식: https://learn.microsoft.com/ko-kr/ef/core/get-started/overview/first-app?tabs=visual-studio https://www.entityframeworktutorial.net/efcore/entity-framework-core.aspx ","date":"2024-02-27T22:44:50+09:00","permalink":"https://blog.plutslet.pe.kr/post/ef-core-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","title":"EF Core 시작하기"},{"content":"input 태그를 사용할 떄 특정 타입만 허용하고 싶을 때가 있습니다.\ninput의 accept를 지정하기만 하면 간단하게 제한할 수 있죠.\n예를 들어 image만 허용하려고 한다면 대략 아래와 같습니다.\n\u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;image/*\u0026#34;\u0026gt; 그런데 파일 선택하는 창에서 모든 파일(.)을 선택할 수 있고, 이때는 accept를 지정해도 의미가 없어집니다.\n이때는 선택한 파일의 확장자를 확인하는 스크립트가 필요하게 되죠.\n선택한 파일을 가져와서 파일의 확장자를 확인하고, 파일의 확장자가 지정해둔 확장자가 맞다면 파일을 허용하는, 그런 절차가 필요해지게 됩니다.\n이런 상황에서 사용할 함수는 아래처럼 작성할 수 있습니다.\n선택한 파일들을 전부 확인하고 모두 image 형태라면 false를 image 형태가 하나라도 아니면 true를 반환하는 함수입니다.\nconst checkFileType = (files: File[]) =\u0026gt; { let result = false for (const file of files) { if (file.type.includes(\u0026#39;image\u0026#39;) !== true) { result = true } } return result } 파일 입력을 받을 때의 이벤트에 아래처럼 사용하면 됩니다.\nif (checkFileType(files)) { inputFileEl.value.value = null alert(\u0026#39;이미지 파일만 첨부 가능합니다.\u0026#39;) return } 저는 vue3에서, 그리고 타입스크립트로 작성하고 사용해서 위의 형태지만, 함수 내부와 if문 내부는 원하는 방식으로 수정하면 됩니다.\n함수의 bool 값을 반대로 설정한다던지, 타입을 다르게 한다던지, 아래 if 내부 처리를 다르게 한다던지 등처럼 말이죠.\n","date":"2024-02-23T22:01:31+09:00","permalink":"https://blog.plutslet.pe.kr/post/input-%ED%83%9C%EA%B7%B8-file-%ED%99%95%EC%9E%A5%EC%9E%90-%EC%A0%9C%ED%95%9C%ED%95%98%EA%B8%B0/","title":"input 태그 file 확장자 제한하기"},{"content":"가끔 모바일 브라우저에서 input 태그를 사용한 입력란을 터치해 입력을 시작할 때 해당 입력란을 확대 시켜서 보여주는 경우가 있습니다.\n확대하지 않는 동작이 프로세스 상 올바른 동작일 때 이를 방지하는 방법이 있습니다.\n방법은 간단한데, index.html의 header 태그 안에서 meta 태그로 viewport 관련해서 설정하는 부분이 있습니다.\n해당 태그 안 content 부분에 user-scalable=no 구문을 추가해주면 입력란을 터치할 때마다 확대하는 걸 방지할 수 있습니다.\n대략 아래와 같이 작성할 수 있습니다.\n\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0,user-scalable=no\u0026#34; /\u0026gt; mata 태그 안에 지정할 수 있는 다양한 옵션값이 있으니 관심있으시면 조금 더 알아보는 것도 좋을 것 같습니다.\n참고 링크 https://talkwithcode.tistory.com/7 https://taeminimini.tistory.com/438 ","date":"2024-02-14T23:19:25+09:00","permalink":"https://blog.plutslet.pe.kr/post/html-%EB%AA%A8%EB%B0%94%EC%9D%BC%EC%97%90%EC%84%9C-input-%ED%83%9C%EA%B7%B8-%ED%81%B4%EB%A6%AD%EC%8B%9C-%ED%99%95%EB%8C%80-%EB%B0%A9%EC%A7%80/","title":"html 모바일에서 input 태그 클릭시 확대 방지"},{"content":"Vue에서 이미지를 동적으로 할당해야하는 부분이 있었습니다.\n대략 /src/assets/images/img.png 이런 느낌의 string 타입을 반환하는 함수를 만들었고, 대략 \u0026lt;img :src=\u0026quot;imgSrc()\u0026quot;\u0026gt; 이런 느낌으로 할당해봤죠.\nnpm run dev 통해 실행한 프로젝트에서는 위의 코드로도 잘 작동해서 문제가 없을 줄 알았습니다.\n하지만 빌드해서 확인한 페이지에서는 이미지가 표시되지 않았습니다.\n이유는 과연 뭘까요?\n문제 문제의 원인을 파악하고 보니 생각보다 간단한 문제였습니다.\n배포된 프로젝트에서 이미지를 가져올 때는 src가 위에서처럼 \u0026lsquo;/\u0026rsquo; 부터 시작하는 상대주소로 되어 있으면 안됩니다.\n상대주소로 된 링크를 참고한다면 대체 어떤 곳을 참고해야 할까요.\n참고할 주소를 찾지 못하게 되는 것이죠.\n로컬호스트이 아니라 빌드하여 배포한 프로젝트라면 src 부분은 \u0026lsquo;http://\u0026rsquo; 부터 시작하는 절대 링크 형태로 구성되어야 합니다.\n그럼, Vue에서 이미지의 src를 동적으로 할당하는 방법을 알아 봅시다.\n해결 아래의 방법을 사용하면 문자열로 된 상대주소를 동적으로 할당할 수 있게 됩니다.\nrequire 사용해 이미지 불러오기\nrequire(`@/assets/images/img.png`) 이미지를 import한다는 의미로 require 구문을 사용할 수 있습니다. config에 사용하도록 설정된 module에 따라 사용할 수 없는 경우가 있습니다.\n동적으로 URL 만들기\nnew URL(`/src/assets/images/img.png`, import.meta.url).href; SSR에서는 동작하지 않는다고 합니다.\n브라우저와 Node.js 에서 import.meta.url의 값이 달라지거나 서버 입장에서도 클라이언트의 호스트 url을 미리 결정할 수 없기 때문이라고 합니다.\npublic 폴더에 이미지 넣기\n\u0026lt;img src=\u0026#34;/images/img.png\u0026#34; /\u0026gt;; 말 그대로 이미지를 프로젝트 내부에서 assets 폴더가 아닌 public에 넣어두는 방법입니다.\npublic 폴더에 넣어두면 상대 주소를 사용해도 정상적으로 불러옵니다.\n참고링크 https://blogcreator.blog/post/39 https://stackoverflow.com/questions/40491506/vue-js-dynamic-images-not-working-with-webpack ","date":"2024-02-14T00:34:14+09:00","permalink":"https://blog.plutslet.pe.kr/post/vue%EC%97%90%EC%84%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-src-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0/","title":"Vue에서 이미지 src 동적으로 할당하기"},{"content":"css에서 hight를 조절하다가 알게된 점을 기록합니다.\n문제 대략 상황은 이랬습니다.\nmain 태그의 높이를 vh 단위로 지정해서 사용하던 중 모바일 환경에서는 높이가 의도한 대로 지정되지 않았습니다.\n태그의 높이를 모바일 브라우저의 상단, 하단 메뉴의 크기를 반영해서 지정하는 것이 아니라 그냥 화면의 크기 만큼 높이를 지정해버리는 것이었죠. 그래서 화면이 일부 잘린 것처럼 보였고, 잘린 부분은 아예 접근할 수 없게 되어 버리는 것입니다.\n해결 여러가지를 조사하던 중 높이 단위가 vh만 있던 게 아니더군요.\n모바일 브라우저에 대응되는 높이 단위는 아래와 같습니다.\nsvh: Small Viewport Height, 가장 작은 화면 영역을 의미하는 높이 단위입니다. 상, 하단 메뉴가 없어도 해당 높이를 반영하여 값을 가져옵니다. lvh: Large Viewport Height, 가장 높은 영역을 의미하는 높이 단위입니다. 상, 하단 메뉴가 있어도 무시한 값을 가져옵니다. dvh: Dynamic Viewport Height, 동적으로 표시되는 영역의 높이 단위입니다. 상, 하단 메뉴를 확인하고 유무에 따라 해당 높이를 반영한 값을 가져옵니다. 즉 위의 높이 단위를 적절히 이용하면, 모바일 브라우저에서 상단, 하단 메뉴가 나타나고 사라지는 과정에서도 메뉴의 높이를 반영한 값을 사용할 수 있는 것이죠.\n저는 조사한 높이 단위 중에서 dvh를 사용했습니다.\n사용법은 아래의 코드처럼 사용할 수 있습니다.\nmain { height:100dvh; } 이 높이 단위를 더 자세히 살펴보고 싶다면 아래의 링크도 확인해주세요.\n더 자세하게 설명되어 있습니다.\n참고 자료 https://web.dev/blog/viewport-units?hl=ko https://mong-blog.tistory.com/entry/CSSJS-vh-버그-해결방법dvh-사용법-js-계산법 ","date":"2024-02-08T00:31:19+09:00","permalink":"https://blog.plutslet.pe.kr/post/%EB%AA%A8%EB%B0%94%EC%9D%BC-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-css-%EB%86%92%EC%9D%B4-%EB%8B%A8%EC%9C%84/","title":"모바일 환경에서의 css 높이 단위"},{"content":"최근 Vue 프로젝트에서 S3 URL을 다운로드되는 기능을 구현해야 하는 일이 있었습니다. fetch를 이용해서 파일을 blob 형태로 받아와 다운로드 시키도록 하도록 처리했죠. 다른 파일들은 다운로드가 잘 이뤄졌는데, 어떤 페이지에서는 이미지가 CORS 오류로 다운로드되지 않는 문제가 발생했습니다. 이 글은 해당 문제를 정리한 내용입니다.\n문제 위에서 언급했듯이 S3 URL을 가지고 있었고, 해당 링크를 이용해 다운로드 되도록 기능을 구현한 상태였습니다.\n다른 페이지에서는 모두 동작하는데, 이미지를 보여주고 해당 이미지를 다운로드 할 수 있는 페이지에서만 CORS 문제를 일으켰습니다.\n콘솔 창에 나타난 문구는 대략 이런 문구였습니다.\nNo \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. Origin \u0026#39;http://localhost:5173\u0026#39; is therefore not allowed access. If an opaque response serves your needs, set the request\u0026#39;s mode to \u0026#39;no-cors\u0026#39; to fetch the resource with CORS disabled. 그래서 오류 메시지 대로 fetch의 모드를 \u0026rsquo;no-cors\u0026rsquo;로 변경하고 다시 테스트 해봤습니다.\n하지만 이제는 파일을 정상적으로 다운로드 받지 못하고 용량이 모두 0 사이즈였습니다.\n그래서 다시 돌려놓고 다른 방향으로 문제를 보기 시작했습니다.\n혹시 페이지에서 이미지를 먼저 불러온게 문제가 된 건 아닐까.\n다르게 말하면 이미지가 캐시된 상태라서 그런 건 아닐까.\n정답부터 말하자면,\n캐시가 문제였습니다.\n해결 문제의 원인은 생각보다 간단했습니다.\nS3의 이미지가 이미 다운로드되어 페이지에서 노출이 되는 상태였고, 해당 이미지는 그렇게 캐시된 상태가 되었습니다.\n그런 다음 fetch를 이용해 이미지 다운로드 받을 경우, 이미 해당 이미지의 캐시가 남아있기 때문에 다운로드 받지 못하는 상태였던 거죠.\n해당 문제를 해결할 때 도움받은 블로그 글은 이사님이 찾아주셨습니다. 아래의 링크를 남겨두었으니 참고해주세요.\n이미지가 캐시가 된 상태라면 캐시 없이 다운로드 받으면 문제는 해결입니다.\n저는 fetch를 이용해 다운로드 받아오기 때문에 아래처럼 옵션을 추가해 주었습니다.\nfetch(\u0026#39;URL\u0026#39;, { cache: \u0026#39;no-cache\u0026#39;}); 저는 추가로 CORS 모드로 설정하는 mode: \u0026quot;cors\u0026quot; 같은 부분 도 추가로 작성해서 다운로드 받도록 하고 있습니다.\n아직 모르는 게 많은 저이지만,\n오늘도 하나씩 배워갑니다.\n참고자료 https://velog.io/@hyesungoh/Webview-app에서-이미지-저장-기능-개발기-w-AWS-s3#aws-s3-cors ","date":"2024-02-02T22:41:19+09:00","permalink":"https://blog.plutslet.pe.kr/post/s3-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C-cors-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0/","title":"S3 이미지 다운로드 CORS 문제 해결"},{"content":"깃허브 페이지로 블로그를 만들 때부터 개인 도메인으로 연결하고 싶다는 생각이 있었습니다. 이 글은 깃허브 페이지에서 커스텀 도메인 설정하며 정리한 내용입니다.\n시작 기본적으로 깃허브 페이지를 만들면 아래의 URL 형태로 만들어 집니다.\nhttps://깃허브아이디.github.io/ 저의 경우는 https://plutslet0316.github.io/ 입니다.\n위의 URL을 아래처럼 제 개인 도메인으로 변경할 생각입니다.\nhttps://blog.plutslet.pe.kr/ 도메인 DNS 설정 현재 사용 중인 DNS 관리 사이트에서 아래의 설정을 진행합니다.\n레코드 타입: CNAME 서브 도메인(Name): 원하는 도메인 - blog 대상 주소: 깃허브아이디.github.io 저는 클라우드플레어를 이용중이고 설정한 예시 이미지는 아래와 같습니다.\n깃허브에서 커스텀 도메인 설정 원하는 저장소에서 Setting → Pages 을 차례로 클릭해 깃허브 페이지 설정창으로 이동합니다. Custom domain 항목을 찾아 입력란에 원하는 도메인을 입력 후 Save 버튼을 클릭합니다. 깃허브에서 DNS 확인을 진행하고, 이후 완료가 되면 해당 도메인으로 접근할 수 있게 됩니다. 아래의 사진은 DNS 설정 후 확인까지 마친 예시 이미지 입니다.\n참고자료 깃허브 공식: https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site Github 블로그에 Custom도메인 연결하기: https://mishka.kr/12 깃허브에 커스텀 도메인 사용하기: https://taedonn.tistory.com/22 깃허브 블로그 개인 도메인: https://wonderbout.tistory.com/120 ","date":"2024-01-30T22:36:50+09:00","permalink":"https://blog.plutslet.pe.kr/post/github-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/","title":"GitHub 페이지 커스텀 도메인 설정하기"},{"content":"Hugo 빌드 속도가 빠릅니다. 핫리로드 기능을 지원합니다. 한글로 작성해도 문제없이 출력됩니다. 요구사항 Git: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git Go: https://go.dev/doc/install 최신버전: go1.21.1.windows-amd64.msi Dart Sass 패치키 툴: https://chocolatey.org/install#individual\nwindow 기준 powershell을 관리자 권한으로 실행 → 아래 명령 복사 후 붙여넣기 → 엔터해서 설치\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) dart-sass: https://gohugo.io/hugo-pipes/transpile-sass-to-css/#dart-sass\n명령 실행 choco install sass Hugo 확장판 설치 위에서 설치한 패키지 툴을 이용해서 확장판설치 choco install hugo-extended Hugo로 블로그 구축하기 원하는 위치에서 hugo new site 폴더이름 해당 위치에 폴더이름으로 hugo 사이트가 만들어 진다. cd 폴더이름 git init https://themes.gohugo.io/ 해당 사이트에서 원하는 테마 찾기 찾은 테마 https://themes.gohugo.io/themes/hugo-theme-stack/ GitHub: https://github.com/CaiJimmy/hugo-theme-stack 테마 적용 - git submodule add git주소 themes/테마이름 예시: git submodule add https://github.com/CaiJimmy/hugo-theme-stack.git themes/stack hugo.toml 수정 baseURL 수정: https://깃허브아이디.github.io/ 테마 지정: theme = '테마이름’ / 예시: theme = 'stack’ 로컬 테스트: hugo server 깃허브에 업로드 깃허브에 업로드하기 위해서 레파지토리가 두개 필요합니다. Hugo로 만들어진 블로그 생성기 (private) Hugo가 랜더링한 정적 블로그 html (public) 레파지토리를 만든 이후 아래의 명령을 수정하고 입력하여 깃허브의 초기 설정을 진행합니다. git remote add origin 1번레파짓토리git주소 git submodule add -b master 2번레파짓토리git주소 public 깃허브 설정 이후 아래의 명령을 통해 빌드하여 깃허브에 업로드 합니다. hugo -D git add . git commit -m \u0026#34;test\u0026#34; git push origin master cd public git add . git commit -m \u0026#34;test\u0026#34; git push origin master 깃허브 페이지 활성화 위에서 만든 2번 레파지토리의 깃허브 페이지를 활성화하면 깃블로그 구축이 완료됩니다.\n참고자료 공식 설치 지침: https://gohugo.io/installation/windows/ 한글 자료Hugo로 개인 블로그 만드는 법: https://selfinvestfriends.tistory.com/78 GitHub Pages 빠른 시작: https://docs.github.com/ko/pages/quickstart 깃허브 페이지(GitHub Pages) 만들기: https://phodobit.kr/49 ","date":"2024-01-24T23:06:58+09:00","permalink":"https://blog.plutslet.pe.kr/post/hugo%EC%99%80-github%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/","title":"Hugo와 GitHub로 블로그 만들기"}]